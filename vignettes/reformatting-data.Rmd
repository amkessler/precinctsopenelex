---
title: "reformatting-data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{reformatting-data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(precinctsopenelex)
library(dplyr)
library(tidyr)
library(stringr)
library(janitor)
library(readxl)
```

This vignette is intended to provide a walk-through of processing a set of precinct results from Saratoga County, NY, for the 2020 U.S. presidential election.  
  
This sample dataset for Saratoga is included with the package to allow for exploration, and provides a template for how the data should be structured for the functions to operate.  

```{r}
#chose state abbreviation and county name variable needed for the input file string
target_state <- "NY"
target_county <- "Saratoga"

#we'll create a name string using a package function to import the data file from Excel based on naming conventions used
infile_string <- create_infile_string(target_state, target_county)

infile_string
```

We'll use the included sample dataset - "precinctsampledata_ny" - to demonstrate that's been cleaned and ready for processing.

```{r}
head(precinctsampledata_ny)

```

```{r}
glimpse(precinctsampledata_ny)
```


Note the precise way of formatting the column names that will allow the function to work correctly:  
* candidate columns should be written as "candidate name - party"  
* additional choices should be listed as "WriteIn" (write-in votes), "Blanks" (undervotes), and "Voids" (overvotes)

```{r}



#now let's run the processing to reformat the data into the open elections standardized format, which is tidy/long
#as opposed to wide

# Function wants:
# - dataset (or import from excel function)
# - office: text label for office (e.g. "U.S. House")
# - district: text label for district (e.g. "42"
#   note that presidential has no district, it's just "")

# *note: the import function itself can be wrapped inside, as long as the data coming in is the correct structure
# processed_prez <- process_ny_data(read_excel(filestring_import, sheet = "presidential"), 
#                                   "President", 
#                                   "")

processed_prez <- reshape_precinct_data(precinctsampledata_ny,
                                  "Presidential",
                                  "")

head(processed_prez, 10)


```

We now have the presidential results in the right format. In a real-world scenario, there would be several different races to process in addition to presidential: U.S Senate and House, along with state House and Senate. They can be done using the same manner.  
    
In the end, once all a county's races are prepared we'll stitch them together into a combined file.

```{r}

#we'll use a pattern matching to pull all dataframes in the environment
#with "processed" in the name and build a list of them to feed to bind_rows()
target_dfs <- grep("processed", names(.GlobalEnv), value=TRUE)
target_dfs_list <- do.call("list", mget(target_dfs))

processed_combined <- bind_rows(target_dfs_list)

```

With the dataset ready, let's do some quick integrity checks to visually inspect.

```{r}
## MANUAL INTEGRITY CHECKS ####
#check parties
processed_combined %>% 
  count(party)

#check districts
processed_combined %>% 
  count(office, district)

#check candidates
processed_combined %>% 
  count(candidate)
```

Now we'll export the results to a csv file named using the standardized OpenElections filename method. The function below provides a shortcut to creating that filename.

```{r}

#build name string using openelex naming convention for 2020 general elex files
outfile_string <- create_outfile_string("NY", "Saratoga")

outfile_string

#export to csv
# not run:
# write_csv(processed_combined, outfile_string, na = "")

```








